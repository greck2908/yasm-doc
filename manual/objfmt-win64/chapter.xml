<?xml version="1.0"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
		"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<!-- $Id$ -->
<chapter id="objfmt-win64">
 <title><literal>win64</literal>: Microsoft Win64 Object Files</title>

 <indexterm>
  <primary><literal>win64</literal></primary>
 </indexterm>

 <indexterm>
  <primary><literal>x64</literal></primary>
 </indexterm>

 <indexterm>
  <primary>PE32+</primary>
 </indexterm>

 <para>The <literal>win64</literal> or <literal>x64</literal> object
  format generates Microsoft Win64 object files for use on the 64-bit
  native Windows x64 platform.  Object files produced using this
  object format may be linked with 64-bit Microsoft linkers such as
  that in Visual Studio 2005 in order to produce 64-bit PE32+
  executables.</para>

 <para><literal>win64</literal> provides a default output filename
  extension of <filename class="extension">.obj</filename>.</para>

 <section id="objfmt-win64-section">
  <title><literal>win64</literal> Extensions to the
   <literal>SECTION</literal> Directive</title>

  <para>Like the <literal>win32</literal> format,
   <literal>win64</literal> allows you to specify additional
   information on the <literal>SECTION</literal> directive line, to
   control the type and properties of sections you declare.</para>
 </section>

 <section id="objfmt-win64-exception">
  <title><literal>win64</literal> Structured Exception
   Handling</title>

  <indexterm>
   <primary><literal>.xdata</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>.pdata</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>x64</literal></primary>
   <secondary>structured exceptions</secondary>
  </indexterm>

  <indexterm>
   <primary>unwind data</primary>
  </indexterm>

  <para>Any x64 functions that make use of the stack in Windows must
   support exception handling even if they make no internal use of
   such facilities.  The reason for this is that when an exception is
   raised the system must be able to identify the function in which it
   occurred and then use this information to find an appropriate
   exception handler and establish an execution context for it.  This
   is done by working backwards through the chain of function calls
   prior to the exception to determine: (a) whether these functions
   have appropriate exception handlers, or (b) whether they have saved
   non-volatile registers that would need to be restored in order to
   establish the execution context for the next higher function in the
   chain.  This process, which is called stack unwinding, depends on
   compilers and assemblers providing <quote>unwind data</quote> for
   functions that use the stack.</para>

  <para>The following sections give the details of the mechanisms that
   are available in Yasm to meet these needs and hence provide
   compliant assembler code functions for the 64 bit versions of
   Windows.  Yasm facilities are very similar to those provided by
   MASM.</para>

  <section id="objfmt-win64-calling-convention">
   <title>x64 Stack, Register and Function Parameter
    Conventions</title>

   <para><xref linkend="win64-calling-convention"/> shows how the
    stack will typically be used in a series of function calls.  When
    a function is entered the first step is to allocate space for
    saving any non-volatile registers that the function uses.
    Additional space may be allocated for local variables and a frame
    pointer register will be set if one is needed.</para>

   <figure id="win64-calling-convention">
    <title>x64 Calling Convention</title>

    <mediaobject>
     <imageobject role="pdf">
      <imagedata fileref="objfmt-win64/calling-convention.eps"
       format="EPS" />
     </imageobject>
     <imageobject role="html">
      <imagedata fileref="calling-convention.png" format="PNG" />
     </imageobject>
    </mediaobject>
   </figure>

   <para>The first four integer parameters for functions are passed
    (in left to right order) in the registers RCX, RDX, R8 and R9.
    Further integer parameters are passed on the stack by pushing them
    in right to left order (so that parameters to the left are closer
    on the stack to the called function).  As shown in <xref
     linkend="win64-calling-convention"/>, <quote>shadow space</quote>
    is allocated for the four register parameters but their values are
    not stored by the calling function.  The called function must
    hence store its parameters here if necessary but it can also use
    this space for other purposes; the called function cannot assume
    this area will be unchanged on return.  Register parameters occupy
    the least significant ends of registers.</para>

   <para>The first four floating point parameters are passed in XMM0
    to XMM3 with the corresponding integer registers not being used.
    Hence if the third parameter after two floating point parameters
    is integer it will be placed in R8 and RCX and RDX will not be
    used.</para>

   <para>When passed by value, structures and unions whose sizes are
    8, 16, 32 or 64 bits are passed as if they are integers of the
    same size.  Arrays and larger structures and unions are passed as
    pointers to memory allocated and assigned by the calling
    function.</para>

   <para>The registers RAX, RCX, RDX, R8, R9, R10, R11 are volatile
    and can be freely used by a called function without preserving
    their values (note, however, that some are used to pass integer
    parameters).  A calling function cannot rely on their value being
    preserved across function calls.</para>

   <para>The registers RBX, RBP, RSI, RDI, R12, R13, R14, and R15 are
    non-volatile and must be saved and restored by any function that
    uses them.  XMM6 to XMM15 are also non-volatile and must also be
    saved if a function uses them.</para>

   <para>Function return values that fit in 64 bits are returned in
    RAX except for floating point values, which are returned in XMM0.
    Some other 128 bit values are also passed in XMM0 but larger
    values are returned in memory assigned by the calling program and
    pointed to by an additional function parameter.  This becomes the
    first parameter and pushes all other parameters to the right.
    This pointer value must also be passed back to the calling program
    in RAX when the called program returns.</para>
  </section>

  <section id="objfmt-win64-function-structure">
   <title>Assembler Function Structure</title>

   <para>Functions that allocate stack space, call other functions,
    save non-volatile registers or use exception handling are called
    frame functions; other functions are called leaf functions. Frame
    functions must have a defined prologue that saves register
    parameters in their shadow locations if necessary, saves any
    non-volatile registers that are used, allocates stack space for
    local variables, and possibly establishes a register as a frame
    pointer.  They must also have one or more defined epilogues that
    restore the non-volatile registers before returning to the calling
    function.  If a frame function calls other functions it must
    maintain the 16 byte alignment of the stack except within its
    prologue and epilogue code. Other frame functions and leaf
    functions do not need to maintain this stack alignment. In
    general, unless dynamic space is being used, a function will not
    change the stack pointer between its prologue and its epilogue
    code.  If it is changed it is then essential that the prologue
    assigns a register as a frame pointer to identify the fixed part
    of the stack.</para>

   <para>A typical function prologue will have the form:</para>

   <programlisting>    mov     [rsp+8],rcx         ; store the first parameter in its shadow space
    push    r14                 ; save a non-volatile register
    push    r13                 ; save a non-volatile register
    sub     rsp,size            ; allocate stack space for local variables
    lea     r13,[128+rsp]       ; use r13 as a frame pointer</programlisting>

   <para>If a large amount of stack space is used it is also necessary
    to call <literal>__chkstk</literal> with size in RAX prior to
    allocating this stack space in order to add memory pages to the
    stack if needed.  The matching form of the epilogue is:</para>

   <programlisting>    lea     rsp,[r13-128]       ; not part of epilogue
    add     rsp,size            ; epilogue starts here
    pop     r13
    pop     r14
    ret</programlisting>

   <para>but the following can also be used:</para>

   <programlisting>    lea     rsp,[r13+size-128]
    pop     r13
    pop     r14
    ret</programlisting>

   <para>These are the only two forms of epilogue allowed: it must
    consist of either an <literal>add rsp,const</literal> or an
    <literal>lea rsp,[frame pointer register+const]</literal>
    instruction followed by zero or more 8 byte register pops and then
    a return instruction (the final instruction can also be one of a
    limited set of jump instructions instead of the return).  Epilogue
    forms are restricted because this allows the exception dispatch
    code to locate them without the need for unwind data in addition
    to that for the prologue.</para>

   <para>All frame functions require prologues and epilogues.  They
    can allocate stack space dynamically provided that they employ a
    register as a frame pointer to identify the fixed part of their
    stack frame.  A frame function without a frame pointer must
    maintain a 16 byte alignment of the stack pointer outside its
    prologue and epilogue code.  Leaf functions and frame functions
    that use frame pointer registers do not need to maintain 16 byte
    stack alignment but the latter need to re-establish such a stack
    alignment if and when they call other functions.</para>
 
   <para>The data on the location and length of each function prologue
    and on the preserved non-volatile registers is recorded in special
    sections in the object code.  Yasm provides a set of macros to
    create this data (called unwind data) that will now be described
    with examples of the way they are used.</para>
  </section>

  <section id="objfmt-win64-frame-details">
   <title>Further Stack Frame Details</title>

   <para>There are two types of stack frame that need to be
    considered in creating unwind data.</para>

   <para>The first, shown at left in <xref
     linkend="win64-stack-frame-detailed"/>, involves only a fixed
    allocation of space on the stack and results in a stack pointer
    that remains fixed in value within a function between the end of
    its prologue and the start of any of its epilogues except in calls
    to other functions.  In this type of stack frame the stack pointer
    value at the end of the prologue is used as the base for the
    offsets used in unwind data to record the position of register
    save data.</para>

   <figure id="win64-stack-frame-detailed">
    <title>x64 Detailed Stack Frame</title>

    <mediaobject>
     <imageobject role="pdf">
      <imagedata fileref="objfmt-win64/stack-frame-detailed.eps"
       format="EPS" />
     </imageobject>
     <imageobject role="html">
      <imagedata fileref="stack-frame-detailed.png" format="PNG" />
     </imageobject>
    </mediaobject>
   </figure>

   <para>In the second type of frame, shown at right in <xref
     linkend="win64-stack-frame-detailed"/>, space is dynamically
    allocated on the stack and this means that the value of the stack
    pointer cannot be used as a basis for unwind offsets.  In this
    situation a frame pointer register must be used to allow the
    unwind code to determine offsets on the stack.  Here the base for
    unwind offsets is the lower end of the fixed allocation area,
    which is usually the value of the stack pointer when the frame
    register value is assigned (which must occur before unwind macros
    with offsets are used).  In order to allow the maximum amount of
    data to be accessed with single byte offsets (-128 to +127) from
    the frame register, it is normal to bias its value from this base
    address towards the centre of the allocated area on the stack.
    The identity of this frame register and offset, which must be a
    multiple of 16 bytes, is recorded in the unwind data and this
    allows the offset base address to be calculated.  When a frame
    register is used, a function is free to change the stack pointer
    but it must align it to a 16 byte boundary if and when it calls
    other functions.</para>
  </section>

  <section id="objfmt-win64-unwind-low-level">
   <title>Low Level Yasm Primitives for Unwind Operations</title>

   <para>Here are the low level facilities Yasm provides to create unwind
    data.</para>

   <variablelist>
    <varlistentry>
     <term><literal>proc_frame
       <replaceable>name</replaceable></literal></term>

     <listitem>
      <para>Generates a function table entry in
       <literal>.pdata</literal> and unwind information in
       <literal>.xdata</literal> for a function's structured exception
       handling data.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>[pushreg
       <replaceable>reg</replaceable>]</literal></term>

     <listitem>
      <para>Generates unwind data for the specified non-volatile
       register.  Used only for non-volatile integer registers; for
       volatile registers use an <literal>[allocstack 8]</literal>
       instead.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>[setframe <replaceable>reg</replaceable>,
      <replaceable>offset</replaceable>]</literal></term>

     <listitem>
      <para>Generates unwind data for a frame register and its stack
       offset.  The offset must be a multiple of 16 and be less than
       or equal to 240.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>[allocstack
      <replaceable>size</replaceable>]</literal></term>

     <listitem>
      <para>Generates unwind data for stack space.  The size must be a
       multiple of 8.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>[savereg <replaceable>reg</replaceable>,
      <replaceable>offset</replaceable>]</literal></term>

     <listitem>
      <para>Generates unwind data for the specified register and
       offset.  The offset must be positive and a multiple of 8. It is
       relative to the base of the procedure's frame as described
       earlier.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>[savexmm128 <replaceable>reg</replaceable>,
      <replaceable>offset</replaceable>]</literal></term>

     <listitem>
      <para>Generates unwind data for the specified XMM register and
       offset. The offset must be positive and a multiple of 16. It is
       relative to the base of the procedure's frame as described
       earlier.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>[pushframe
      <replaceable>code</replaceable>]</literal></term>

     <listitem>
      <para>Generates unwind data for the storage of the whole fixed
       stack frame with an optional error code. If the optional code
       is specified the unwind code entry is given a modifier of 1;
       otherwise it is 0.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>[endprolog]</literal></term>

     <listitem>
      <para>Signals the end of the prologue (must be in the first 255
       bytes of the function).</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>endproc_frame</literal></term>

     <listitem>
      <para>Used at the end of functions started with
       <literal>proc_frame</literal>.</para>
     </listitem>
    </varlistentry>
   </variablelist>

   <para>Here is an example of how they are used (based on a Microsoft
    example with MASM).</para>

   <programlisting>PROC_FRAME      sample   
    db          0x48            ; emit a REX prefix to enable hot-patching
    push        rbp
    [pushreg    rbp]            ; create unwind data for an rbp register push
    sub         rsp,0x40
    [allocstack 0x40]           ; create unwind data for stack allocation
    lea         rbp,[rsp+0x20]
    [setframe   rbp,0x20]       ; create unwind data for a frame register in rbp
    movdqa      [rbp],xmm7
    [savexmm128 xmm7, 0x20]     ; create unwind data for an XMM register save
    mov         [rbp+0x18],rsi
    [savereg    rsi,0x38]       ; create unwind data for a save of rsi
    mov         [rsp+0x10],rdi
    [savereg    rdi, 0x10]      ; create unwind data for a save of rdi
END_PROLOGUE

    ; We can change the stack pointer outside of the prologue because we
    ; have a frame pointer.  If we didn't have one this would be illegal.
    ; A frame pointer is needed because of this stack pointer modification.

    sub         rsp,0x60        ; we are free to modify the stack pointer
    mov         rax,0           ; we can unwind this access violation 
    mov         rax,[rax]

    movdqa      xmm7,[rbp]      ; restore the registers that weren't saved
    mov         rsi,[rbp+0x18]  ; with a push; this isn't part of the
    mov         rdi,[rbp-0x10]  ; official epilog

    lea         rsp,[rbp-0x20]  ; This is the official epilog
    pop         rbp
    ret
ENDPROC_FRAME</programlisting>
  </section>

  <section id="objfmt-win64-unwind-high-level">
   <title>High Level Macros for Unwind Operations</title>

   <para>It can be seen that there is a close association between
    stack operations and the related unwind macros and this allows
    higher level macros to be used to combine these operations into
    single macro instructions.  The following macros all perform
    operations and create the related unwind data.</para>

   <variablelist>
    <varlistentry>
     <term><literal>proc_frame
      <replaceable>name</replaceable></literal></term>

     <listitem>
      <para>Generates a function table entry in
       <literal>.pdata</literal> and unwind information in
       <literal>.xdata</literal> for a function's structured exception
       handling data.</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>alloc_stack
      <replaceable>n</replaceable></literal></term>

     <listitem>
      <para>Allocates a stack area of <replaceable>n</replaceable>
       bytes</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>save_reg <replaceable>reg</replaceable>,
      <replaceable>loc</replaceable></literal></term>

     <listitem>
      <para>Saves a non-volatile register
       <replaceable>reg</replaceable> at offset
       <replaceable>loc</replaceable> on the stack</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>push_reg
      <replaceable>reg</replaceable></literal></term>

     <listitem>
      <para>Pushes a non-volatile register
       <replaceable>reg</replaceable> on the stack</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>rex_push_reg
      <replaceable>reg</replaceable></literal></term>

     <listitem>
      <para>Pushes a non-volatile register
       <replaceable>reg</replaceable> on the stack using a 2 byte push
       instruction</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>save_xmm128 <replaceable>reg</replaceable>,
      <replaceable>loc</replaceable></literal></term>

     <listitem>
      <para>Saves a non-volatile XMM register
       <replaceable>reg</replaceable> at offset
       <replaceable>loc</replaceable> on the stack</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>set_frame <replaceable>reg</replaceable>,
      <replaceable>loc</replaceable></literal></term>

     <listitem>
      <para>Sets the frame register <replaceable>reg</replaceable> to
       offset <replaceable>loc</replaceable> on the stack</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>push_eflags</literal></term>

     <listitem>
      <para>Pushes the eflags register</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>push_rex_eflags</literal></term>

     <listitem>
      <para>Pushes the eflags register using a 2 byte push instruction
       (allows hot patching).</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>push_frame
      <replaceable>code</replaceable></literal></term>

     <listitem>
      <para>Pushes the whole frame onto the stack with an optional
       code</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>end_prologue</literal></term>

     <listitem>
      <para>Ends the function prologue (this is an alternative to
       <literal>[endprolog]</literal>)</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>endproc_frame</literal></term>
     
     <listitem>
      <para>Used at the end of funtions started with
       <literal>proc_frame</literal>.</para>
     </listitem>
    </varlistentry>
   </variablelist>

   <para>Here is the previous example using these higher level
    macros.</para>

   <programlisting>PROC_FRAME       sample         ; start the prologue
    rex_push_reg rbp            ; push the prospective frame pointer
    alloc_stack  0x40           ; allocate 64 bytes of local stack space
    set_frame    rbp, 0x20      ; set a frame register to [rsp+32]
    save_xmm128  xmm7,0x20      ; save xmm7, rsi &amp; rdi to the local stack space
    save_reg     rsi, 0x38      ; the unwind base address is [rsp on entry - 72]
    save_reg     rdi, 0x10      ; the frame register is [rsp on entry - 40]
END_PROLOGUE
    sub          rsp,0x60       ; we can change the stack pointer
    mov          rax,0          ; and unwind this access violation 
    mov          rax,[rax]      ; because we have a frame pointer

    movdqa       xmm7,[rbp]     ; restore the registers that weren't saved with
    mov          rsi,[rbp+0x18] ; a push (not a part of the official epilog)
    mov          rdi,[rbp-0x10]

    lea          rsp,[rbp-0x20] ; the official epilogue
    pop          rbp
    ret
ENDPROC_FRAME</programlisting>
  </section>
 </section>
</chapter>
