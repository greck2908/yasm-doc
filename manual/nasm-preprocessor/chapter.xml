<?xml version="1.0"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
		"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<!-- $Id$ -->
<chapter id="nasm-preprocessor">
 <chapterinfo>
  <authorgroup>
   <corpauthor>The NASM Development Team</corpauthor>

   <author>
    <firstname>Peter</firstname>
    <surname>Johnson</surname>
    <contrib>Updated for Yasm context by </contrib>
   </author>
  </authorgroup>
 </chapterinfo>

 <title>The NASM Preprocessor</title>

 <indexterm>
  <primary>macro processor</primary>
 </indexterm>

 <para>NASM contains a powerful macro processor, which supports
  conditional assembly, multi-level file inclusion, two forms of macro
  (single-line and multi-line), and a <quote>context stack</quote>
  mechanism for extra macro power. Preprocessor directives all begin
  with a <literal>%</literal> sign.</para>

 <para>The preprocessor collapses all lines which end with a backslash
  (\\) character into a single line.  Thus:</para>

 <programlisting>%define THIS_VERY_LONG_MACRO_NAME_IS_DEFINED_TO \\
          THIS_VALUE</programlisting>

 <para>will work like a single-line macro without the backslash-newline
  sequence.</para>

 <section id="nasm-single-line-macros">
  <title>Single-Line Macros</title>

  <indexterm>
   <primary>Single-Line Macros</primary>
  </indexterm>

  <section id="nasm-macro-define">
   <title>The Normal Way: <literal>%define</literal></title>

   <indexterm>
    <primary><literal>%idefine</literal></primary>
   </indexterm>

   <indexterm>
    <primary><literal>%define</literal></primary>
   </indexterm>

   <para>Single-line macros are defined using the
    <literal>%define</literal> preprocessor directive. The definitions
    work in a similar way to C; so you can do things like</para>

   <programlisting><![CDATA[%define ctrl    0x1F &
%define param(a,b) ((a)+(a)*(b))

        mov     byte [param(2,ebx)], ctrl 'D']]></programlisting>

   <para>which will expand to</para>

   <programlisting><![CDATA[        mov     byte [(2)+(2)*(ebx)], 0x1F & 'D']]></programlisting>

   <para>When the expansion of a single-line macro contains tokens
    which invoke another macro, the expansion is performed at
    invocation time, not at definition time. Thus the code</para>

   <programlisting>%define a(x)    1+b(x)
%define b(x)    2*x

        mov     ax,a(8)</programlisting>

   <para>will evaluate in the expected way to <literal>mov
     ax,1+2*8</literal>, even though the macro <literal>b</literal>
    wasn't defined at the time of definition of
    <literal>a</literal>.</para>

   <indexterm>
    <primary>case sensitive</primary>
   </indexterm>

   <para>Macros defined with <literal>%define</literal> are case
    sensitive: after <literal>%define foo bar</literal>, only
    <literal>foo</literal> will expand to <literal>bar</literal>:
    <literal>Foo</literal> or <literal>FOO</literal> will not. By
    using <literal>%idefine</literal> instead of
    <literal>%define</literal> (the <quote>i</quote> stands for
    <quote>insensitive</quote>) you can define all the case variants
    of a macro at once, so that <literal>%idefine foo bar</literal>
    would cause <literal>foo</literal>, <literal>Foo</literal>,
    <literal>FOO</literal>, <literal>fOO</literal> and so on all to
    expand to <literal>bar</literal>.</para>

   <indexterm>
    <primary>circular references</primary>
   </indexterm>

   <para>There is a mechanism which detects when a macro call has
    occurred as a result of a previous expansion of the same macro, to
    guard against circular references and infinite loops. If this
    happens, the preprocessor will only expand the first occurrence of
    the macro.  Hence, if you code</para>

   <programlisting>%define a(x)    1+a(x)

        mov     ax,a(3)</programlisting>

   <para>the macro <literal>a(3)</literal> will expand once, becoming
    <literal>1+a(3)</literal>, and will then expand no further. This
    behaviour can be useful.</para>

   <indexterm>
    <primary>overloading</primary>
    <secondary>single-line macros</secondary>
   </indexterm>

   <para>You can overload single-line macros: if you write</para>

   <programlisting>%define foo(x)   1+x
%define foo(x,y) 1+x*y</programlisting>

   <para>the preprocessor will be able to handle both types of macro
    call, by counting the parameters you pass; so
    <literal>foo(3)</literal> will become <literal>1+3</literal>
    whereas <literal>foo(ebx,2)</literal> will become
    <literal>1+ebx*2</literal>. However, if you define</para>

   <programlisting>%define foo bar</programlisting>

   <para>then no other definition of <literal>foo</literal> will be
    accepted: a macro with no parameters prohibits the definition of
    the same name as a macro <emphasis>with</emphasis> parameters, and
    vice versa.</para>

   <para>This doesn't prevent single-line macros being
    <emphasis>redefined</emphasis>: you can perfectly well define a
    macro with</para>

   <programlisting>%define foo bar</programlisting>

   <para>and then re-define it later in the same source file
    with</para>

   <programlisting>%define foo baz</programlisting>

   <para>Then everywhere the macro <literal>foo</literal> is invoked,
    it will be expanded according to the most recent definition. This
    is particularly useful when defining single-line macros with
    <literal>%assign</literal> (see <xref linkend="nasm-macro-assign"
     />).</para>

   <indexterm>
    <primary>pre-define</primary>
   </indexterm>

   <para>You can pre-define single-line macros using the
    <quote>-D</quote> option on the Yasm command line: see <xref
     linkend="yasm-option-d" />.</para>
  </section>

  <section id="nasm-macro-xdefine">
   <title>Enhancing %define: <literal>%xdefine</literal></title>

   <indexterm>
    <primary><literal>%xidefine</literal></primary>
   </indexterm>

   <indexterm>
    <primary><literal>%xdefine</literal></primary>
   </indexterm>

   <indexterm>
    <primary>case sensitive</primary>
   </indexterm>

   <para>To have a reference to an embedded single-line macro resolved
    at the time that it is embedded, as opposed to when the calling
    macro is expanded, you need a different mechanism to the one
    offered by <literal>%define</literal>. The solution is to use
    <literal>%xdefine</literal>, or it's case-insensitive counterpart
    <literal>%xidefine</literal>.</para>

   <para>Suppose you have the following code:</para>

   <programlisting>%define  isTrue  1
%define  isFalse isTrue
%define  isTrue  0

val1:    db      isFalse

%define  isTrue  1

val2:    db      isFalse</programlisting>

   <para>In this case, <literal>val1</literal> is equal to 0, and
    <literal>val2</literal> is equal to 1.  This is because, when a
    single-line macro is defined using <literal>%define</literal>, it
    is expanded only when it is called. As <literal>isFalse</literal>
    expands to <literal>isTrue</literal>, the expansion will be the
    current value of <literal>isTrue</literal>. The first time it is
    called that is 0, and the second time it is 1.</para>

   <para>If you wanted <literal>isFalse</literal> to expand to the
    value assigned to the embedded macro <literal>isTrue</literal> at
    the time that <literal>isFalse</literal> was defined, you need to
    change the above code to use <literal>%xdefine</literal>.</para>

   <programlisting>%xdefine isTrue  1
%xdefine isFalse isTrue
%xdefine isTrue  0

val1:    db      isFalse

%xdefine isTrue  1

val2:    db      isFalse</programlisting>

   <para>Now, each time that <literal>isFalse</literal> is called, it
    expands to 1, as that is what the embedded macro
    <literal>isTrue</literal> expanded to at the time that
    <literal>isFalse</literal> was defined.</para>
  </section>

  <section id="nasm-macro-single-concat">
   <title>Concatenating Single Line Macro Tokens:
    <literal>%+</literal></title>

   <indexterm>
    <primary><literal>%+</literal></primary>
   </indexterm>

   <para>Individual tokens in single line macros can be concatenated,
    to produce longer tokens for later processing. This can be useful
    if there are several similar macros that perform similar
    functions.</para>

   <para>As an example, consider the following:</para>

   <programlisting>%define BDASTART 400h                ; Start of BIOS data area

struc   tBIOSDA                      ; its structure
        .COM1addr       RESW    1
        .COM2addr       RESW    1
        ; ..and so on
endstruc</programlisting>

   <para>Now, if we need to access the elements of tBIOSDA in
    different places, we can end up with:</para>

   <programlisting>        mov     ax,BDASTART + tBIOSDA.COM1addr
        mov     bx,BDASTART + tBIOSDA.COM2addr</programlisting>

   <para>This will become pretty ugly (and tedious) if used in many
    places, and can be reduced in size significantly by using the
    following macro:</para>

   <programlisting>; Macro to access BIOS variables by their names (from tBDA):

%define BDA(x)  BDASTART + tBIOSDA. %+ x</programlisting>

   <para>Now the above code can be written as:</para>

   <programlisting>        mov     ax,BDA(COM1addr)
        mov     bx,BDA(COM2addr)</programlisting>

   <para>Using this feature, we can simplify references to a lot of
    macros (and, in turn, reduce typing errors).</para>
  </section>

  <section id="nasm-macro-undef">
   <title>Undefining macros: <literal>%undef</literal></title>

   <indexterm>
    <primary><literal>%undef</literal></primary>
   </indexterm>

   <para>Single-line macros can be removed with the
    <literal>%undef</literal> command.  For example, the following
    sequence:</para>

   <programlisting>%define foo bar
%undef  foo

        mov     eax, foo</programlisting>

   <para>will expand to the instruction <literal>mov eax,
     foo</literal>, since after <literal>%undef</literal> the macro
    <literal>foo</literal> is no longer defined.</para>

   <para>Macros that would otherwise be pre-defined can be undefined
    on the command-line using the <quote>-U</quote> option on the Yasm
    command line: see <xref linkend="yasm-option-u" />.</para>
  </section>

  <section id="nasm-macro-assign">
   <title>Preprocessor Variables: <literal>%assign</literal></title>

   <indexterm>
    <primary>Preprocessor Variables</primary>
   </indexterm>

   <indexterm>
    <primary><literal>%assign</literal></primary>
   </indexterm>

   <indexterm>
    <primary><literal>%iassign</literal></primary>
   </indexterm>

   <indexterm>
    <primary>case sensitive</primary>
   </indexterm>

   <para>An alternative way to define single-line macros is by means
    of the <literal>%assign</literal> command (and its
    case-insensitive counterpart <literal>%iassign</literal>, which
    differs from <literal>%assign</literal> in exactly the same way
    that <literal>%idefine</literal> differs from
    <literal>%define</literal>).</para>

   <para><literal>%assign</literal> is used to define single-line
    macros which take no parameters and have a numeric value. This
    value can be specified in the form of an expression, and it will
    be evaluated once, when the <literal>%assign</literal> directive
    is processed.</para>

   <para>Like <literal>%define</literal>, macros defined using
    <literal>%assign</literal> can be re-defined later, so you can do
    things like</para>

   <programlisting>%assign i i+1</programlisting>

   <para>to increment the numeric value of a macro.</para>

   <para><literal>%assign</literal> is useful for controlling the
    termination of <literal>%rep</literal> preprocessor loops: see
    <xref linkend="nasm-macro-rep" /> for an example of this.</para>

   <indexterm>
    <primary>critical expression</primary>
   </indexterm>

   <para>The expression passed to <literal>%assign</literal> is a
    critical expression (see <xref linkend="nasm-crit" />), and must
    also evaluate to a pure number (rather than a relocatable
    reference such as a code or data address, or anything involving a
    register).</para>
  </section>
 </section>

 <section id="nasm-strlen">
  <title>String Handling in Macros: <literal>%strlen</literal> and
   <literal>%substr</literal></title>

  <indexterm>
   <primary>String Handling in Macros</primary>
  </indexterm>

  <indexterm>
   <primary><literal>%strlen</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>%substr</literal></primary>
  </indexterm>

  <para>It's often useful to be able to handle strings in macros.
   NASM supports two simple string handling macro operators from which
   more complex operations can be constructed.</para>

  <section id="nasm-macro-strlen">
   <title>String Length: <literal>%strlen</literal></title>

   <indexterm>
    <primary>String Length</primary>
   </indexterm>

   <indexterm>
    <primary><literal>%strlen</literal></primary>
   </indexterm>

   <para>The <literal>%strlen</literal> macro is like
    <literal>%assign</literal> macro in that it creates (or redefines)
    a numeric value to a macro. The difference is that with
    <literal>%strlen</literal>, the numeric value is the length of a
    string. An example of the use of this would be:</para>

   <programlisting>%strlen charcnt 'my string'</programlisting>

   <para>In this example, <literal>charcnt</literal> would receive the
    value 8, just as if an <literal>%assign</literal> had been used.
    In this example, <literal>'my string'</literal> was a literal
    string but it could also have been a single-line macro that
    expands to a string, as in the following example:</para>

   <programlisting>%define sometext 'my string'
%strlen charcnt sometext</programlisting>

   <para>As in the first case, this would result in
    <literal>charcnt</literal> being assigned the value of 8.</para>
  </section>

  <section id="nasm-macro-substr">
   <title>Sub-strings: <literal>%substr</literal></title>

   <indexterm>
    <primary>Sub-strings</primary>
   </indexterm>

   <indexterm>
    <primary><literal>%substr</literal></primary>
   </indexterm>

   <para>Individual letters in strings can be extracted using
    <literal>%substr</literal>.  An example of its use is probably
    more useful than the description:</para>

   <programlisting>%substr mychar  'xyz' 1         ; equivalent to %define mychar 'x'
%substr mychar  'xyz' 2         ; equivalent to %define mychar 'y'
%substr mychar  'xyz' 3         ; equivalent to %define mychar 'z'</programlisting>

   <para>In this example, mychar gets the value of 'y'. As with
    <literal>%strlen</literal> (see <xref linkend="nasm-macro-strlen"
     />), the first parameter is the single-line macro to be created
    and the second is the string. The third parameter specifies which
    character is to be selected. Note that the first index is 1, not 0
    and the last index is equal to the value that
    <literal>%strlen</literal> would assign given the same string.
    Index values out of range result in an empty string.</para>
  </section>
 </section>

 <section id="nasm-multi-line-macros">
  <title>Multi-Line Macros: <literal>%macro</literal></title>

  <indexterm>
   <primary>Multi-Line Macros</primary>
  </indexterm>

  <indexterm>
   <primary><literal>%imacro</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>%macro</literal></primary>
  </indexterm>

  <para>Multi-line macros are much more like the type of macro seen in
   MASM and TASM: a multi-line macro definition in NASM looks
   something like this.</para>

  <programlisting>%macro  prologue 1

        push    ebp
        mov     ebp,esp
        sub     esp,%1

%endmacro</programlisting>

  <para>This defines a C-like function prologue as a macro: so you
   would invoke the macro with a call such as</para>

  <programlisting>myfunc:   prologue 12</programlisting>

  <para>which would expand to the three lines of code</para>

  <programlisting>myfunc: push    ebp
        mov     ebp,esp
        sub     esp,12</programlisting>

  <para>The number <literal>1</literal> after the macro name in the
   <literal>%macro</literal> line defines the number of parameters the
   macro <literal>prologue</literal> expects to receive.  The use of
   <literal>%1</literal> inside the macro definition refers to the
   first parameter to the macro call. With a macro taking more than
   one parameter, subsequent parameters would be referred to as
   <literal>%2</literal>, <literal>%3</literal> and so on.</para>

  <indexterm>
   <primary>case-sensitive</primary>
  </indexterm>

  <para>Multi-line macros, like single-line macros, are
   case-sensitive, unless you define them using the alternative
   directive <literal>%imacro</literal>.</para>

  <indexterm>
   <primary>braces</primary>
   <secondary>around macro parameters</secondary>
  </indexterm>

  <para>If you need to pass a comma as <emphasis>part</emphasis> of a
   parameter to a multi-line macro, you can do that by enclosing the
   entire parameter in braces. So you could code things like</para>

  <programlisting>%macro  silly 2

    %2: db      %1

%endmacro

        silly 'a', letter_a             ; letter_a:  db 'a'
        silly 'ab', string_ab           ; string_ab: db 'ab'
        silly {13,10}, crlf             ; crlf:      db 13,10</programlisting>

  <section id="nasm-macro-overloading">
   <title>Overloading Multi-Line Macros</title>

   <indexterm>
    <primary>overloading</primary>
    <secondary>multi-line macros</secondary>
   </indexterm>

   <para>As with single-line macros, multi-line macros can be
    overloaded by defining the same macro name several times with
    different numbers of parameters. This time, no exception is made
    for macros with no parameters at all. So you could define</para>

   <programlisting>%macro  prologue 0

        push    ebp
        mov     ebp,esp

%endmacro</programlisting>

   <para>to define an alternative form of the function prologue which
    allocates no local stack space.</para>

   <para>Sometimes, however, you might want to `overload' a machine
    instruction; for example, you might want to define</para>

   <programlisting>%macro  push 2

        push    %1
        push    %2

%endmacro</programlisting>

   <para>so that you could code</para>

   <programlisting>        push    ebx             ; this line is not a macro call
        push    eax,ecx         ; but this one is</programlisting>

   <para>Ordinarily, NASM will give a warning for the first of the
    above two lines, since <literal>push</literal> is now defined to
    be a macro, and is being invoked with a number of parameters for
    which no definition has been given. The correct code will still be
    generated, but the assembler will give a warning. This warning can
    be disabled by the use of the \c{-w-macro-params} command-line
    option (see <xref linkend="yasm-warning-options" />).</para>
  </section>

  <section id="nasm-macro-local">
   <title>Macro-Local Labels</title>

   <indexterm>
    <primary>Macro-Local Labels</primary>
   </indexterm>

   <indexterm>
    <primary><literal>%%</literal></primary>
   </indexterm>

   <para>NASM allows you to define labels within a multi-line macro
    definition in such a way as to make them local to the macro call:
    so calling the same macro multiple times will use a different
    label each time. You do this by prefixing <literal>%%</literal> to
    the label name. So you can invent an instruction which executes a
    <literal>RET</literal> if the <literal>Z</literal> flag is set by
    doing this:</para>

   <programlisting>%macro  retz 0

        jnz     %%skip
        ret
    %%skip:

%endmacro</programlisting>

   <indexterm>
    <primary><literal>..@</literal></primary>
   </indexterm>

   <para>You can call this macro as many times as you want, and every
    time you call it NASM will make up a different `real' name to
    substitute for the label <literal>%%skip</literal>. The names NASM
    invents are of the form <literal>..@2345.skip</literal>, where the
    number 2345 changes with every macro call. The
    <literal>..@</literal> prefix prevents macro-local labels from
    interfering with the local label mechanism, as described in <xref
     linkend="nasm-local-label" />. You should avoid defining your own
    labels in this form (the <literal>..@</literal> prefix, then a
    number, then another period) in case they interfere with
    macro-local labels.</para>
  </section>

  <section id="nasm-macro-greedy">
   <title>Greedy Macro Parameters</title>

   <indexterm>
    <primary>Greedy Macro Parameters</primary>
   </indexterm>

   <para>Occasionally it is useful to define a macro which lumps its
    entire command line into one parameter definition, possibly after
    extracting one or two smaller parameters from the front. An
    example might be a macro to write a text string to a file in
    MS-DOS, where you might want to be able to write</para>

   <programlisting>        writefile [filehandle],"hello, world",13,10</programlisting>

   <para>NASM allows you to define the last parameter of a macro to be
    <emphasis>greedy</emphasis>, meaning that if you invoke the macro
    with more parameters than it expects, all the spare parameters get
    lumped into the last defined one along with the separating commas.
    So if you code:</para>

   <programlisting>%macro  writefile 2+

        jmp     %%endstr
  %%str:        db      %2
  %%endstr:
        mov     dx,%%str
        mov     cx,%%endstr-%%str
        mov     bx,%1
        mov     ah,0x40
        int     0x21

%endmacro</programlisting>

   <para>then the example call to <literal>writefile</literal> above
    will work as expected: the text before the first comma,
    <literal>[filehandle]</literal>, is used as the first macro
    parameter and expanded when <literal>%1</literal> is referred to,
    and all the subsequent text is lumped into <literal>%2</literal>
    and placed after the <literal>db</literal>.</para>

   <indexterm>
    <primary>+ modifier</primary>
   </indexterm>

   <para>The greedy nature of the macro is indicated to NASM by the
    use of the <literal>+</literal> sign after the parameter count on
    the <literal>%macro</literal> line.</para>

   <para>If you define a greedy macro, you are effectively telling
    NASM how it should expand the macro given <emphasis>any</emphasis>
    number of parameters from the actual number specified up to
    infinity; in this case, for example, NASM now knows what to do
    when it sees a call to <literal>writefile</literal> with 2, 3, 4
    or more parameters.  NASM will take this into account when
    overloading macros, and will not allow you to define another form
    of <literal>writefile</literal> taking 4 parameters (for
    example).</para>

   <para>Of course, the above macro could have been implemented as a
    non-greedy macro, in which case the call to it would have had to
    look like</para>

   <programlisting>        writefile [filehandle], {"hello, world",13,10}</programlisting>

   <indexterm>
    <primary>commas in macro parameters</primary>
   </indexterm>

   <para>NASM provides both mechanisms for putting commas in macro
    parameters, and you choose which one you prefer for each macro
    definition.</para>

   <para>See <xref linkend="nasm-directive-section-macro" /> for a
    better way to write the above macro.</para>
  </section>

  <section id="nasm-macro-default">
   <title>Default Macro Parameters</title>

   <indexterm>
    <primary>Default Macro Parameters</primary>
   </indexterm>

   <indexterm>
    <primary>omitted parameters</primary>
   </indexterm>

   <para>NASM also allows you to define a multi-line macro with a
    <emphasis>range</emphasis> of allowable parameter counts.  If you
    do this, you can specify defaults for omitted parameters.  So, for
    example:</para>

   <programlisting>%macro  die 0-1 "Painful program death has occurred."

        writefile 2,%1
        mov     ax,0x4c01
        int     0x21

%endmacro</programlisting>

   <para>This macro (which makes use of the
    <literal>writefile</literal> macro defined in <xref
     linkend="nasm-macro-greedy" />) can be called with an explicit
    error message, which it will display on the error output stream
    before exiting, or it can be called with no parameters, in which
    case it will use the default error message supplied in the macro
    definition.</para>

   <para>In general, you supply a minimum and maximum number of
    parameters for a macro of this type; the minimum number of
    parameters are then required in the macro call, and then you
    provide defaults for the optional ones. So if a macro definition
    began with the line</para>

   <programlisting>%macro foobar 1-3 eax,[ebx+2]</programlisting>

   <para>then it could be called with between one and three
    parameters, and <literal>%1</literal> would always be taken from
    the macro call.  <literal>%2</literal>, if not specified by the
    macro call, would default to <literal>eax</literal>, and
    <literal>%3</literal> if not specified would default to
    <literal>[ebx+2]</literal>.</para>

   <indexterm>
    <primary><literal>%0</literal></primary>
   </indexterm>

   <para>You may omit parameter defaults from the macro definition, in
    which case the parameter default is taken to be blank. This can be
    useful for macros which can take a variable number of parameters,
    since the <literal>%0</literal> token (see <xref
     linkend="nasm-macro-percent0" />) allows you to determine how
    many parameters were really passed to the macro call.</para>

   <para>This defaulting mechanism can be combined with the
    greedy-parameter mechanism; so the <literal>die</literal> macro
    above could be made more powerful, and more useful, by changing
    the first line of the definition to</para>

   <programlisting>%macro die 0-1+ "Painful program death has occurred.",13,10</programlisting>

   <para>The maximum parameter count can be infinite, denoted by
    <literal>*</literal>. In this case, of course, it is impossible to
    provide a <emphasis>full</emphasis> set of default parameters.
    Examples of this usage are shown in <xref
     linkend="nasm-macro-rotate" />.</para>
  </section>

  <section id="nasm-macro-percent0">
   <title><literal>%0</literal>: Macro Parameter Counter</title>

   <indexterm>
    <primary><literal>%0</literal></primary>
   </indexterm>

   <indexterm>
    <primary>counting macro parameters</primary>
   </indexterm>

   <para>For a macro which can take a variable number of parameters,
    the parameter reference <literal>%0</literal> will return a
    numeric constant giving the number of parameters passed to the
    macro. This can be used as an argument to <literal>%rep</literal>
    (see <xref linkend="nasm-macro-rep" />) in order to iterate
    through all the parameters of a macro.  Examples are given in
    <xref linkend="nasm-macro-rotate" />.</para>
  </section>

  <section id="nasm-macro-rotate">
   <title><literal>%rotate</literal>: Rotating Macro Parameters</title>

   <indexterm>
    <primary><literal>%rotate</literal></primary>
   </indexterm>

   <indexterm>
    <primary>Rotating Macro Parameters</primary>
   </indexterm>

   <indexterm>
    <primary>shift command</primary>
   </indexterm>

   <para>Unix shell programmers will be familiar with the
    <literal>shift</literal> shell command, which allows the arguments
    passed to a shell script (referenced as <literal>$1</literal>,
    <literal>$2</literal> and so on) to be moved left by one place, so
    that the argument previously referenced as <literal>$2</literal>
    becomes available as <literal>$1</literal>, and the argument
    previously referenced as <literal>$1</literal> is no longer
    available at all.</para>

   <para>NASM provides a similar mechanism, in the form of
    <literal>%rotate</literal>. As its name suggests, it differs from
    the Unix <literal>shift</literal> in that no parameters are lost:
    parameters rotated off the left end of the argument list reappear
    on the right, and vice versa.</para>

   <para><literal>%rotate</literal> is invoked with a single numeric
    argument (which may be an expression). The macro parameters are
    rotated to the left by that many places. If the argument to
    <literal>%rotate</literal> is negative, the macro parameters are
    rotated to the right.</para>

   <indexterm>
    <primary>iterating over macro parameters</primary>
   </indexterm>
     
   <para>So a pair of macros to save and restore a set of registers
    might work as follows:</para>

   <programlisting>%macro  multipush 1-*

  %rep  %0
        push    %1
  %rotate 1
  %endrep

%endmacro</programlisting>

   <para>This macro invokes the <literal>PUSH</literal> instruction on
    each of its arguments in turn, from left to right. It begins by
    pushing its first argument, <literal>%1</literal>, then invokes
    <literal>%rotate</literal> to move all the arguments one place to
    the left, so that the original second argument is now available as
    <literal>%1</literal>. Repeating this procedure as many times as
    there were arguments (achieved by supplying <literal>%0</literal>
    as the argument to <literal>%rep</literal>) causes each argument
    in turn to be pushed.</para>

   <indexterm>
    <primary><literal>multipush</literal></primary>
   </indexterm>

   <para>Note also the use of <literal>*</literal> as the maximum
    parameter count, indicating that there is no upper limit on the
    number of parameters you may supply to the
    <literal>multipush</literal> macro.</para>

   <para>It would be convenient, when using this macro, to have a
    <literal>POP</literal> equivalent, which
    <emphasis>didn't</emphasis> require the arguments to be given in
    reverse order. Ideally, you would write the
    <literal>multipush</literal> macro call, then cut-and-paste the
    line to where the pop needed to be done, and change the name of
    the called macro to <literal>multipop</literal>, and the macro
    would take care of popping the registers in the opposite order
    from the one in which they were pushed.</para>

   <para>This can be done by the following definition:</para>

   <programlisting>%macro  multipop 1-*

  %rep %0
  %rotate -1
        pop     %1
  %endrep

%endmacro</programlisting>

   <para>This macro begins by rotating its arguments one place to the
    <emphasis>right</emphasis>, so that the original
    <emphasis>last</emphasis> argument appears as
    <literal>%1</literal>.  This is then popped, and the arguments are
    rotated right again, so the second-to-last argument becomes
    <literal>%1</literal>. Thus the arguments are iterated through in
    reverse order.</para>
  </section>

  <section id="nasm-macro-concat">
   <title>Concatenating Macro Parameters</title>

   <indexterm>
    <primary>Concatenating Macro Parameters</primary>
   </indexterm>

   <para>NASM can concatenate macro parameters on to other text
    surrounding them. This allows you to declare a family of symbols,
    for example, in a macro definition. If, for example, you wanted to
    generate a table of key codes along with offsets into the table,
    you could code something like</para>

   <programlisting>%macro keytab_entry 2

    keypos%1    equ     $-keytab
                db      %2

%endmacro

keytab:
          keytab_entry F1,128+1
          keytab_entry F2,128+2
          keytab_entry Return,13</programlisting>

   <para>which would expand to</para>

   <programlisting>keytab:
keyposF1        equ     $-keytab
                db     128+1
keyposF2        equ     $-keytab
                db      128+2
keyposReturn    equ     $-keytab
                db      13</programlisting>

   <para>You can just as easily concatenate text on to the other end
    of a macro parameter, by writing <literal>%1foo</literal>.</para>

   <indexterm>
    <primary>braces</primary>
    <secondary>after % sign</secondary>
   </indexterm>

   <para>If you need to append a <emphasis>digit</emphasis> to a macro
    parameter, for example defining labels <literal>foo1</literal> and
    <literal>foo2</literal> when passed the parameter
    <literal>foo</literal>, you can't code <literal>%11</literal>
    because that would be taken as the eleventh macro parameter.
    Instead, you must code <literal>%{1}1</literal>, which will
    separate the first <literal>1</literal> (giving the number of the
    macro parameter) from the second (literal text to be concatenated
    to the parameter).</para>

   <para>This concatenation can also be applied to other preprocessor
    in-line objects, such as macro-local labels (<xref
     linkend="nasm-macro-local" />) and context-local labels (<xref
     linkend="nasm-macro-context-local" />). In all cases, ambiguities
    in syntax can be resolved by enclosing everything after the
    <literal>%</literal> sign and before the literal text in braces:
    so <literal>%{%foo}bar</literal> concatenates the text
    <literal>bar</literal> to the end of the real name of the
    macro-local label <literal>%%foo</literal>. (This is unnecessary,
    since the form NASM uses for the real names of macro-local labels
    means that the two usages <literal>%{%foo}bar</literal> and
    <literal>%%foobar</literal> would both expand to the same thing
    anyway; nevertheless, the capability is there.)</para>
  </section>

  <section id="nasm-macro-cc">
   <title>Condition Codes as Macro Parameters</title>

   <indexterm>
    <primary>Condition Codes as Macro Parameters</primary>
   </indexterm>

   <indexterm>
    <primary><literal>%+1</literal></primary>
   </indexterm>

   <para>NASM can give special treatment to a macro parameter which
    contains a condition code. For a start, you can refer to the macro
    parameter <literal>%1</literal> by means of the alternative syntax
    <literal>%+1</literal>, which informs NASM that this macro
    parameter is supposed to contain a condition code, and will cause
    the preprocessor to report an error message if the macro is called
    with a parameter which is <emphasis>not</emphasis> a valid
    condition code.</para>

   <indexterm>
    <primary><literal>%-1</literal></primary>
   </indexterm>

   <indexterm>
    <primary>conditional-return macro</primary>
   </indexterm>

   <para>Far more usefully, though, you can refer to the macro
    parameter by means of <literal>%-1</literal>, which NASM will
    expand as the <emphasis>inverse</emphasis> condition code. So the
    <literal>retz</literal> macro defined in <xref
     linkend="nasm-macro-local" /> can be replaced by a general
    conditional-return macro like this:</para>

   <programlisting>%macro  retc 1

        j%-1    %%skip
        ret
  %%skip:

%endmacro</programlisting>

   <para>This macro can now be invoked using calls like <literal>retc
     ne</literal>, which will cause the conditional-jump instruction
    in the macro expansion to come out as <literal>JE</literal>, or
    <literal>retc po</literal> which will make the jump a
    <literal>JPE</literal>.</para>

   <para>The <literal>%+1</literal> macro-parameter reference is quite
    happy to interpret the arguments <literal>CXZ</literal> and
    <literal>ECXZ</literal> as valid condition codes; however,
    <literal>%-1</literal> will report an error if passed either of
    these, because no inverse condition code exists.</para>
  </section>

  <section id="nasm-macro-nolist">
   <title>Disabling Listing Expansion</title>

   <indexterm>
    <primary>Disabling Listing Expansion</primary>
   </indexterm>

   <indexterm>
    <primary><literal>.nolist</literal></primary>
   </indexterm>

   <para>When NASM is generating a listing file from your program, it
    will generally expand multi-line macros by means of writing the
    macro call and then listing each line of the expansion. This
    allows you to see which instructions in the macro expansion are
    generating what code; however, for some macros this clutters the
    listing up unnecessarily.</para>

   <para>NASM therefore provides the <literal>.nolist</literal>
    qualifier, which you can include in a macro definition to inhibit
    the expansion of the macro in the listing file. The
    <literal>.nolist</literal> qualifier comes directly after the
    number of parameters, like this:</para>

   <programlisting>%macro foo 1.nolist</programlisting>

   <para>Or like this:</para>

   <programlisting>%macro bar 1-5+.nolist a,b,c,d,e,f,g,h</programlisting>
  </section>
 </section>

 <section id="nasm-macro-conditional">
  <title>Conditional Assembly</title>

  <indexterm>
   <primary>Conditional Assembly</primary>
  </indexterm>

  <indexterm>
   <primary><literal>%if</literal></primary>
  </indexterm>

  <para>Similarly to the C preprocessor, NASM allows sections of a
   source file to be assembled only if certain conditions are met.
   The general syntax of this feature looks like this:</para>

  <programlisting><![CDATA[%if<condition>
    ; some code which only appears if <condition> is met
%elif<condition2>
    ; only appears if <condition> is not met but <condition2> is
%else
    ; this appears if neither <condition> nor <condition2> was met
%endif]]></programlisting>

  <indexterm>
   <primary><literal>%else</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>%elif</literal></primary>
  </indexterm>

  <para>The <literal>%else</literal> clause is optional, as is the
   <literal>%elif</literal> clause.  You can have more than one
   <literal>%elif</literal> clause as well.</para>

  <section id="nasm-macro-ifdef">
   <title><literal>%ifdef</literal>: Testing Single-Line Macro
    Existence</title>

   <indexterm>
    <primary><literal>%ifdef</literal></primary>
   </indexterm>

   <indexterm>
    <primary>testing</primary>
    <secondary>single-line macro existence</secondary>
   </indexterm>

   <para>Beginning a conditional-assembly block with the line
    <literal>%ifdef MACRO</literal> will assemble the subsequent code
    if, and only if, a single-line macro called
    <literal>MACRO</literal> is defined.  If not, then the
    <literal>%elif</literal> and <literal>%else</literal> blocks (if
    any) will be processed instead.</para>

   <para>For example, when debugging a program, you might want to
    write code such as</para>

   <programlisting>          ; perform some function
%ifdef DEBUG
          writefile 2,"Function performed successfully",13,10
%endif
          ; go and do something else</programlisting>

   <para>Then you could use the command-line option <literal>-D
     DEBUG</literal> to create a version of the program which produced
    debugging messages, and remove the option to generate the final
    release version of the program.</para>

   <indexterm>
    <primary><literal>%ifndef</literal></primary>
   </indexterm>

   <indexterm>
    <primary><literal>%elifdef</literal></primary>
   </indexterm>

   <indexterm>
    <primary><literal>%elifndef</literal></primary>
   </indexterm>

   <para>You can test for a macro <emphasis>not</emphasis> being
    defined by using <literal>%ifndef</literal> instead of
    <literal>%ifdef</literal>. You can also test for macro definitions
    in <literal>%elif</literal> blocks by using
    <literal>%elifdef</literal> and
    <literal>%elifndef</literal>.</para>
  </section>

  <section id="nasm-macro-ifmacro">
   <title><literal>%ifmacro</literal>: Testing Multi-Line Macro
    Existence</title>

   <indexterm>
    <primary><literal>%ifmacro</literal></primary>
   </indexterm>

   <indexterm>
    <primary>testing</primary>
    <secondary>multi-line macro existence</secondary>
   </indexterm>

   <para>The <literal>%ifmacro</literal> directive operates in the
    same way as the <literal>%ifdef</literal> directive, except that
    it checks for the existence of a multi-line macro.</para>

   <para>For example, you may be working with a large project and not
    have control over the macros in a library. You may want to create
    a macro with one name if it doesn't already exist, and another
    name if one with that name does exist.</para>

   <para>The <literal>%ifmacro</literal> is considered true if
    defining a macro with the given name and number of arguments would
    cause a definitions conflict. For example:</para>

   <programlisting>%ifmacro MyMacro 1-3

     %error "MyMacro 1-3" causes a conflict with an existing macro.

%else

     %macro MyMacro 1-3

             ; insert code to define the macro

     %endmacro

%endif</programlisting>

   <para>This will create the macro <literal>MyMacro 1-3</literal> if
    no macro already exists which would conflict with it, and emits a
    warning if there would be a definition conflict.</para>

   <indexterm>
    <primary><literal>%ifnmacro</literal></primary>
   </indexterm>

   <indexterm>
    <primary><literal>%elifmacro</literal></primary>
   </indexterm>

   <indexterm>
    <primary><literal>%elifnmacro</literal></primary>
   </indexterm>

   <para>You can test for the macro not existing by using the
    <literal>%ifnmacro</literal> instead of
    <literal>%ifmacro</literal>. Additional tests can be performed in
    <literal>%elif</literal>} blocks by using
    <literal>%elifmacro</literal> and
    <literal>%elifnmacro</literal>.</para>
  </section>

  <section id="nasm-macro-ifctx">
   <title><literal>%ifctx</literal>: Testing the Context Stack</title>

   <indexterm>
    <primary><literal>%ifctx</literal></primary>
   </indexterm>

   <indexterm>
    <primary>testing</primary>
    <secondary>context stack</secondary>
   </indexterm>

   <indexterm>
    <primary><literal>%ifnctx</literal></primary>
   </indexterm>

   <indexterm>
    <primary><literal>%elifctx</literal></primary>
   </indexterm>

   <indexterm>
    <primary><literal>%elifnctx</literal></primary>
   </indexterm>

   <para>The conditional-assembly construct <literal>%ifctx
     ctxname</literal> will cause the subsequent code to be assembled
    if and only if the top context on the preprocessor's context stack
    has the name <literal>ctxname</literal>. As with
    <literal>%ifdef</literal>, the inverse and
    <literal>%elif</literal> forms <literal>%ifnctx</literal>,
    <literal>%elifctx</literal> and <literal>%elifnctx</literal> are
    also supported.</para>

   <para>For more details of the context stack, see <xref
     linkend="nasm-macro-context-stack" />. For a sample use of
    <literal>%ifctx</literal>, see <xref linkend="nasm-macro-block-if"
     />.</para>
  </section>

  <section id="nasm-macro-if">
   <title><literal>%if</literal>: Testing Arbitrary Numeric
    Expressions</title>

   <indexterm>
    <primary><literal>%if</literal></primary>
   </indexterm>

   <indexterm>
    <primary>testing</primary>
    <secondary>arbitrary numeric expressions</secondary>
   </indexterm>

   <para>The conditional-assembly construct <literal>%if
     expr</literal> will cause the subsequent code to be assembled if
    and only if the value of the numeric expression
    <literal>expr</literal> is non-zero. An example of the use of this
    feature is in deciding when to break out of a
    <literal>%rep</literal> preprocessor loop: see <xref
     linkend="nasm-macro-rep" /> for a detailed example.</para>

   <indexterm>
    <primary><literal>%elif</literal></primary>
   </indexterm>

   <para>The expression given to <literal>%if</literal>, and its
    counterpart <literal>%elif</literal>, is a critical expression
    (see <xref linkend="nasm-crit" />).</para>

   <indexterm>
    <primary>relational operators</primary>
   </indexterm>

   <indexterm>
    <primary><literal>=</literal></primary>
   </indexterm>

   <indexterm>
    <primary><literal>&lt;</literal></primary>
   </indexterm>

   <indexterm>
    <primary><literal>&gt;</literal></primary>
   </indexterm>

   <indexterm>
    <primary><literal>&lt;=</literal></primary>
   </indexterm>

   <indexterm>
    <primary><literal>&gt;=</literal></primary>
   </indexterm>

   <indexterm>
    <primary><literal>&lt;&gt;</literal></primary>
   </indexterm>

   <indexterm>
    <primary><literal>==</literal></primary>
   </indexterm>

   <indexterm>
    <primary><literal>!=</literal></primary>
   </indexterm>

   <indexterm>
    <primary><literal>&amp;&amp;</literal></primary>
   </indexterm>

   <indexterm>
    <primary><literal>^^</literal></primary>
   </indexterm>

   <indexterm>
    <primary><literal>||</literal></primary>
   </indexterm>

   <indexterm>
    <primary>logical AND</primary>
   </indexterm>

   <indexterm>
    <primary>logical XOR</primary>
   </indexterm>

   <indexterm>
    <primary>logical OR</primary>
   </indexterm>

   <para><literal>%if</literal> extends the normal NASM expression
    syntax, by providing a set of \i{relational operators} which are
    not normally available in expressions. The operators
    <literal>=</literal>, <literal>&lt;</literal>,
    <literal>&gt;</literal>, <literal>&lt;=</literal>,
    <literal>&gt;=</literal> and <literal>&lt;&gt;</literal> test
    equality, less-than, greater-than, less-or-equal, greater-or-equal
    and not-equal respectively. The C-like forms <literal>==</literal>
    and <literal>!=</literal> are supported as alternative forms of
    <literal>=</literal> and <literal>&lt;&gt;</literal>. In addition,
    low-priority logical operators <literal>&amp;&amp;</literal>,
    <literal>^^</literal> and <literal>||</literal> are provided,
    supplying logical AND, logical XOR and logical OR. These work like
    the C logical operators (although C has no logical XOR), in that
    they always return either 0 or 1, and treat any non-zero input as
    1 (so that <literal>^^</literal>, for example, returns 1 if
    exactly one of its inputs is zero, and 0 otherwise).  The
    relational operators also return 1 for true and 0 for
    false.</para>
  </section>

  <section id="nasm-macro-ifidn">
   <title><literal>%ifidn</literal> and <literal>%ifidni</literal>:
    Testing Exact Text Identity</title>

   <indexterm>
    <primary><literal>%ifidn</literal></primary>
   </indexterm>

   <indexterm>
    <primary><literal>%ifidni</literal></primary>
   </indexterm>

   <indexterm>
    <primary>testing</primary>
    <secondary>exact text identity</secondary>
   </indexterm>

   <para>The construct <literal>%ifidn text1,text2</literal> will
    cause the subsequent code to be assembled if and only if
    <literal>text1</literal> and <literal>text2</literal>, after
    expanding single-line macros, are identical pieces of text.
    Differences in white space are not counted.</para>

   <indexterm>
    <primary>case-insensitive</primary>
   </indexterm>

   <para><literal>%ifidni</literal> is similar to
    <literal>%ifidn</literal>, but is case-insensitive.</para>

   <para>For example, the following macro pushes a register or number
    on the stack, and allows you to treat <literal>IP</literal> as a
    real register:</para>

   <programlisting>%macro  pushparam 1

  %ifidni %1,ip
        call    %%label
  %%label:
  %else
        push    %1
  %endif

%endmacro</programlisting>

   <indexterm>
    <primary><literal>%elifidn</literal></primary>
   </indexterm>

   <indexterm>
    <primary><literal>%ifnidn</literal></primary>
   </indexterm>

   <indexterm>
    <primary><literal>%elifnidn</literal></primary>
   </indexterm>

   <indexterm>
    <primary><literal>%elifidni</literal></primary>
   </indexterm>

   <indexterm>
    <primary><literal>%ifnidni</literal></primary>
   </indexterm>

   <indexterm>
    <primary><literal>%elifnidni</literal></primary>
   </indexterm>

   <para>Like most other <literal>%if</literal> constructs,
    <literal>%ifidn</literal> has a counterpart
    <literal>%elifidn</literal>, and negative forms
    <literal>%ifnidn</literal> and <literal>%elifnidn</literal>.
    Similarly, <literal>%ifidni</literal> has counterparts
    <literal>%elifidni</literal>, <literal>%ifnidni</literal> and
    <literal>%elifnidni</literal>.</para>
  </section>

  <section id="nasm-macro-iftyp">
   <title><literal>%ifid</literal>, <literal>%ifnum</literal>,
    <literal>%ifstr</literal>: Testing Token Types</title>

   <indexterm>
    <primary><literal>%ifid</literal></primary>
   </indexterm>

   <indexterm>
    <primary><literal>%ifnum</literal></primary>
   </indexterm>

   <indexterm>
    <primary><literal>%ifstr</literal></primary>
   </indexterm>

   <indexterm>
    <primary>testing</primary>
    <secondary>token types</secondary>
   </indexterm>

   <para>Some macros will want to perform different tasks depending on
    whether they are passed a number, a string, or an identifier. For
    example, a string output macro might want to be able to cope with
    being passed either a string constant or a pointer to an existing
    string.</para>

   <para>The conditional assembly construct <literal>%ifid</literal>,
    taking one parameter (which may be blank), assembles the
    subsequent code if and only if the first token in the parameter
    exists and is an identifier.  <literal>%ifnum</literal> works
    similarly, but tests for the token being a numeric constant;
    <literal>%ifstr</literal> tests for it being a string.</para>

   <para>For example, the <literal>writefile</literal> macro defined
    in <xref linkend="nasm-macro-greedy" /> can be extended to take
    advantage of <literal>%ifstr</literal> in the following
    fashion:</para>

   <programlisting>%macro writefile 2-3+

  %ifstr %2
        jmp     %%endstr
    %if %0 = 3
      %%str:    db      %2,%3
    %else
      %%str:    db      %2
    %endif
      %%endstr: mov     dx,%%str
                mov     cx,%%endstr-%%str
  %else
                mov     dx,%2
                mov     cx,%3
  %endif
                mov     bx,%1
                mov     ah,0x40
                int     0x21

%endmacro</programlisting>

   <para>Then the <literal>writefile</literal> macro can cope with
    being called in either of the following two ways:</para>

   <programlisting>        writefile [file], strpointer, length
        writefile [file], "hello", 13, 10</programlisting>

   <para>In the first, <literal>strpointer</literal> is used as the
    address of an already-declared string, and
    <literal>length</literal> is used as its length; in the second, a
    string is given to the macro, which therefore declares it itself
    and works out the address and length for itself.</para>

   <para>Note the use of <literal>%if</literal> inside the
    <literal>%ifstr</literal>: this is to detect whether the macro was
    passed two arguments (so the string would be a single string
    constant, and <literal>db %2</literal> would be adequate) or more
    (in which case, all but the first two would be lumped together
    into <literal>%3</literal>, and <literal>db %2,%3</literal> would
    be required).</para>

   <indexterm>
    <primary><literal>%ifnid</literal></primary>
   </indexterm>

   <indexterm>
    <primary><literal>%elifid</literal></primary>
   </indexterm>

   <indexterm>
    <primary><literal>%elifnid</literal></primary>
   </indexterm>

   <indexterm>
    <primary><literal>%ifnnum</literal></primary>
   </indexterm>

   <indexterm>
    <primary><literal>%elifnum</literal></primary>
   </indexterm>

   <indexterm>
    <primary><literal>%elifnnum</literal></primary>
   </indexterm>

   <indexterm>
    <primary><literal>%ifnstr</literal></primary>
   </indexterm>

   <indexterm>
    <primary><literal>%elifstr</literal></primary>
   </indexterm>

   <indexterm>
    <primary><literal>%elifnstr</literal></primary>
   </indexterm>

   <para>The usual <literal>%elifXXX</literal>,
    <literal>%ifnXXX</literal> and <literal>%elifnXXX</literal>
    versions exist for each of <literal>%ifid</literal>,
    <literal>%ifnum</literal> and <literal>%ifstr</literal>.</para>
  </section>

  <section id="nasm-macro-error">
   <title><literal>%error</literal>: Reporting User-Defined
    Errors</title>

   <indexterm>
    <primary><literal>%error</literal></primary>
   </indexterm>

   <indexterm>
    <primary>User-Defined Errors</primary>
   </indexterm>

   <para>The preprocessor directive <literal>%error</literal> will
    cause NASM to report an error if it occurs in assembled code. So
    if other users are going to try to assemble your source files, you
    can ensure that they define the right macros by means of code like
    this:</para>

   <programlisting>%ifdef SOME_MACRO
    ; do some setup
%elifdef SOME_OTHER_MACRO
    ; do some different setup
%else
    %error Neither SOME_MACRO nor SOME_OTHER_MACRO was defined.
%endif</programlisting>

   <para>Then any user who fails to understand the way your code is
    supposed to be assembled will be quickly warned of their mistake,
    rather than having to wait until the program crashes on being run
    and then not knowing what went wrong.</para>
  </section>
 </section>

 <section id="nasm-macro-rep">
  <title>Preprocessor Loops: <literal>%rep</literal></title>

  <indexterm>
   <primary>Preprocessor Loops</primary>
  </indexterm>

  <indexterm>
   <primary>repeating code</primary>
  </indexterm>

  <indexterm>
   <primary><literal>%rep</literal></primary>
  </indexterm>

  <para>NASM's <literal>TIMES</literal> prefix, though useful, cannot
   be used to invoke a multi-line macro multiple times, because it is
   processed by NASM after macros have already been expanded.
   Therefore NASM provides another form of loop, this time at the
   preprocessor level: <literal>%rep</literal>.</para>

  <indexterm>
   <primary><literal>%endrep</literal></primary>
  </indexterm>

  <para>The directives <literal>%rep</literal> and
   <literal>%endrep</literal> (<literal>%rep</literal> takes a numeric
   argument, which can be an expression; <literal>%endrep</literal>
   takes no arguments) can be used to enclose a chunk of code, which
   is then replicated as many times as specified by the
   preprocessor:</para>

  <programlisting>%assign i 0
%rep    64
        inc     word [table+2*i]
%assign i i+1
%endrep</programlisting>

  <para>This will generate a sequence of 64 <literal>INC</literal>
   instructions, incrementing every word of memory from
   <literal>[table]</literal> to
   <literal>[table+126]</literal>.</para>

  <indexterm>
   <primary><literal>%exitrep</literal></primary>
  </indexterm>

  <para>For more complex termination conditions, or to break out of a
   repeat loop part way along, you can use the
   <literal>%exitrep</literal> directive to terminate the loop, like
   this:</para>

  <programlisting>fibonacci:
%assign i 0
%assign j 1
%rep 100
%if j > 65535
    %exitrep
%endif
        dw j
%assign k j+i
%assign i j
%assign j k
%endrep

fib_number equ ($-fibonacci)/2</programlisting>

  <para>This produces a list of all the Fibonacci numbers that will
   fit in 16 bits. Note that a maximum repeat count must still be
   given to <literal>%rep</literal>. This is to prevent the
   possibility of NASM getting into an infinite loop in the
   preprocessor, which (on multitasking or multi-user systems) would
   typically cause all the system memory to be gradually used up and
   other applications to start crashing.</para>
 </section>

 <section id="nasm-include">
  <title>Including Other Files</title>

  <indexterm>
   <primary>Including Other Files</primary>
  </indexterm>

  <indexterm>
   <primary><literal>%include</literal></primary>
  </indexterm>

  <para>Using, once again, a very similar syntax to the C
   preprocessor, the NASM preprocessor lets you include other source
   files into your code. This is done by the use of the
   <literal>%include</literal> directive:</para>

  <programlisting>%include "macros.mac"</programlisting>

  <para>will include the contents of the file
   <filename>macros.mac</filename> into the source file containing the
   <literal>%include</literal> directive.</para>

  <indexterm>
   <primary>searching for include files</primary>
  </indexterm>

  <para>Include files are first searched for relative to the directory
   containing the source file that is performing the inclusion, and
   then relative to any directories specified on the Yasm command line
   using the <literal>-I</literal> option (see <xref
    linkend="yasm-option-i" />), in the order given on the command
   line (any relative paths on the Yasm command line are relative to
   the current working directory, e.g. where Yasm is being run from).
   While this search strategy does not match traditional NASM
   behavior, it does match the behavior of most C compilers and better
   handles relative pathnames.</para>

  <para>The standard C idiom for preventing a file being included more
   than once is just as applicable in the NASM preprocessor: if the
   file <filename>macros.mac</filename> has the form</para>

  <programlisting>%ifndef MACROS_MAC
    %define MACROS_MAC
    ; now define some macros
%endif</programlisting>

  <para>then including the file more than once will not cause errors,
   because the second time the file is included nothing will happen
   because the macro <literal>MACROS_MAC</literal> will already be
   defined.</para>

  <indexterm>
   <primary><literal>-P</literal></primary>
  </indexterm>

  <para>You can force a file to be included even if there is no
   <literal>%include</literal> directive that explicitly includes it,
   by using the <literal>-P</literal> option on the Yasm command line
   (see <xref linkend="yasm-option-p" />).</para>
 </section>

 <section id="nasm-macro-context-stack">
  <title>The Context Stack</title>

  <indexterm>
   <primary>Context Stack</primary>
  </indexterm>

  <para>Having labels that are local to a macro definition is
   sometimes not quite powerful enough: sometimes you want to be able
   to share labels between several macro calls. An example might be a
   <literal>REPEAT</literal> ... <literal>UNTIL</literal> loop, in
   which the expansion of the <literal>REPEAT</literal> macro would
   need to be able to refer to a label which the
   <literal>UNTIL</literal> macro had defined. However, for such a
   macro you would also want to be able to nest these loops.</para>

  <indexterm>
   <primary><literal>%push</literal></primary>
  </indexterm>

  <indexterm>
   <primary><literal>%pop</literal></primary>
  </indexterm>

  <para>The NASM preprocessor provides this level of power by means of
   a <emphasis>context stack</emphasis>.  The preprocessor maintains a
   stack of <emphasis>contexts</emphasis>, each of which is
   characterised by a name.  You add a new context to the stack using
   the <literal>%push</literal> directive, and remove one using
   <literal>%pop</literal>. You can define labels that are local to a
   particular context on the stack.</para>

  <section id="nasm-macro-pushpop">
   <title><literal>%push</literal> and <literal>%pop</literal>:
    Creating and Removing Contexts</title>

   <indexterm>
    <primary><literal>%push</literal></primary>
   </indexterm>

   <indexterm>
    <primary><literal>%pop</literal></primary>
   </indexterm>

   <indexterm>
    <primary>creating contexts</primary>
   </indexterm>

   <indexterm>
    <primary>removing contexts</primary>
   </indexterm>

   <para>The <literal>%push</literal> directive is used to create a
    new context and place it on the top of the context stack.
    <literal>%push</literal> requires one argument, which is the name
    of the context. For example:</para>

   <programlisting>%push    foobar</programlisting>

   <para>This pushes a new context called <literal>foobar</literal> on
    the stack. You can have several contexts on the stack with the
    same name: they can still be distinguished.</para>

   <para>The directive <literal>%pop</literal>, requiring no
    arguments, removes the top context from the context stack and
    destroys it, along with any labels associated with it.</para>
  </section>

  <section id="nasm-macro-context-local">
   <title>Context-Local Labels</title>

   <indexterm>
    <primary>Context-Local Labels</primary>
   </indexterm>

   <indexterm>
    <primary><literal>%$</literal></primary>
   </indexterm>

   <para>Just as the usage <literal>%%foo</literal> defines a label
    which is local to the particular macro call in which it is used,
    the usage <literal>%$foo</literal> is used to define a label which
    is local to the context on the top of the context stack. So the
    <literal>REPEAT</literal> and <literal>UNTIL</literal> example
    given above could be implemented by means of:</para>

   <programlisting>%macro repeat 0

    %push   repeat
    %$begin:

%endmacro

%macro until 1

        j%-1    %$begin
    %pop

%endmacro</programlisting>

   <para>and invoked by means of, for example,</para>

   <programlisting>        mov     cx,string
        repeat
        add     cx,3
        scasb
        until   e</programlisting>

   <para>which would scan every fourth byte of a string in search of the byte
    in <literal>AL</literal>.</para>

   <indexterm>
    <primary><literal>%$$</literal></primary>
   </indexterm>

   <para>If you need to define, or access, labels local to the context
    <emphasis>below</emphasis> the top one on the stack, you can use
    <literal>%$$foo</literal>, or <literal>%$$$foo</literal> for the
    context below that, and so on.</para>
  </section>

  <section id="nasm-macro-context-define">
   <title>Context-Local Single-Line Macros</title>

   <indexterm>
    <primary>Context-Local Single-Line Macros</primary>
   </indexterm>

   <para>The NASM preprocessor also allows you to define single-line
    macros which are local to a particular context, in just the same
    way:</para>

   <programlisting>%define %$localmac 3</programlisting>

   <para>will define the single-line macro
    <literal>%$localmac</literal> to be local to the top context on
    the stack. Of course, after a subsequent <literal>%push</literal>,
    it can then still be accessed by the name
    <literal>%$$localmac</literal>.</para>
  </section>

  <section id="nasm-macro-repl">
   <title><literal>%repl</literal>: Renaming a Context</title>

   <indexterm>
    <primary><literal>%repl</literal></primary>
   </indexterm>

   <indexterm>
    <primary>renaming contexts</primary>
   </indexterm>

   <para>If you need to change the name of the top context on the
    stack (in order, for example, to have it respond differently to
    <literal>%ifctx</literal>), you can execute a
    <literal>%pop</literal> followed by a <literal>%push</literal>;
    but this will have the side effect of destroying all context-local
    labels and macros associated with the context that was just
    popped.</para>

   <para>The NASM preprocessor provides the directive
    <literal>%repl</literal>, which <emphasis>replaces</emphasis> a
    context with a different name, without touching the associated
    macros and labels. So you could replace the destructive
    code</para>

   <programlisting>%pop
%push   newname</programlisting>

   <para>with the non-destructive version <literal>%repl
     newname</literal>.</para>
  </section>

  <section id="nasm-macro-block-if">
   <title>Example Use of the Context Stack: Block IFs</title>

   <indexterm>
    <primary>Context Stack</primary>
   </indexterm>

   <indexterm>
    <primary>Block IFs</primary>
   </indexterm>

   <indexterm>
    <primary><literal>%ifctx</literal></primary>
   </indexterm>

   <para>This example makes use of almost all the context-stack
    features, including the conditional-assembly construct
    <literal>%ifctx</literal>, to implement a block IF statement as a
    set of macros.</para>

   <programlisting>%macro if 1

    %push if
    j%-1  %$ifnot

%endmacro

%macro else 0

  %ifctx if
        %repl   else
        jmp     %$ifend
        %$ifnot:
  %else
        %error  "expected `if' before `else'"
  %endif

%endmacro

%macro endif 0

  %ifctx if
        %$ifnot:
        %pop
  %elifctx      else
        %$ifend:
        %pop
  %else
        %error  "expected `if' or `else' before `endif'"
  %endif

%endmacro</programlisting>

   <para>This code is more robust than the <literal>REPEAT</literal>
    and <literal>UNTIL</literal> macros given in <xref
     linkend="nasm-macro-context-local" />, because it uses
    conditional assembly to check that the macros are issued in the
    right order (for example, not calling <literal>endif</literal>
    before <literal>if</literal>) and issues a
    <literal>%error</literal> if they're not.</para>

   <para>In addition, the <literal>endif</literal> macro has to be
    able to cope with the two distinct cases of either directly
    following an <literal>if</literal>, or following an
    <literal>else</literal>. It achieves this, again, by using
    conditional assembly to do different things depending on whether
    the context on top of the stack is <literal>if</literal> or
    <literal>else</literal>.</para>

   <para>The <literal>else</literal> macro has to preserve the context
    on the stack, in order to have the <literal>%$ifnot</literal>
    referred to by the <literal>if</literal> macro be the same as the
    one defined by the <literal>endif</literal> macro, but has to
    change the context's name so that <literal>endif</literal> will
    know there was an intervening <literal>else</literal>. It does
    this by the use of <literal>%repl</literal>.</para>

   <para>A sample usage of these macros might look like:</para>

   <programlisting>        cmp     ax,bx

        if ae
               cmp     bx,cx

               if ae
                       mov     ax,cx
               else
                       mov     ax,bx
               endif

        else
               cmp     ax,cx

               if ae
                       mov     ax,cx
               endif

        endif</programlisting>

   <para>The block-<literal>IF</literal> macros handle nesting quite
    happily, by means of pushing another context, describing the inner
    <literal>if</literal>, on top of the one describing the outer
    <literal>if</literal>; thus <literal>else</literal> and
    <literal>endif</literal> always refer to the last unmatched
    <literal>if</literal> or <literal>else</literal>.</para>
  </section>
 </section>

 <section id="nasm-stdmac">
  <title>Standard Macros</title>

  <indexterm>
   <primary>Standard Macros</primary>
  </indexterm>

  <indexterm>
   <primary><literal>%clear</literal></primary>
  </indexterm>

  <para>Yasm defines a set of standard macros in the NASM preprocessor
   which are already defined when it starts to process any source
   file. If you really need a program to be assembled with no
   pre-defined macros, you can use the <literal>%clear</literal>
   directive to empty the preprocessor of everything.</para>

  <indexterm>
   <primary>user-level assembler directives</primary>
  </indexterm>

  <para>Most user-level NASM syntax directives (see <xref
    linkend="nasm-directives" />) are implemented as macros which
   invoke primitive directives; these are described in <xref
    linkend="nasm-directives" />.  The rest of the standard macro set
   is described here.</para>

  <section id="nasm-stdmac-version">
   <title><literal>__YASM_MAJOR__</literal>, etc: Yasm Version</title>

   <indexterm>
    <primary><literal>__YASM_MAJOR__</literal></primary>
   </indexterm>

   <indexterm>
    <primary><literal>__YASM_MINOR__</literal></primary>
   </indexterm>

   <indexterm>
    <primary><literal>__YASM_SUBMINOR__</literal></primary>
   </indexterm>

   <indexterm>
    <primary><literal>__YASM_BUILD__</literal></primary>
   </indexterm>

   <indexterm>
    <primary><literal>__YASM_VERSION_ID__</literal></primary>
   </indexterm>

   <indexterm>
    <primary><literal>__YASM_VER__</literal></primary>
   </indexterm>

   <indexterm>
    <primary>Yasm Version</primary>
   </indexterm>

   <indexterm>
    <primary>version number of Yasm</primary>
   </indexterm>

   <para>The single-line macros <literal>__YASM_MAJOR__</literal>,
    <literal>__YASM_MINOR__</literal>, and
    <literal>__YASM_SUBMINOR__</literal> expand to the major, minor,
    and subminor parts of the version number of Yasm being used.  In
    addition, <literal>__YASM_VER__</literal> expands to a string
    representation of the Yasm version and
    <literal>__YASM_VERSION_ID__</literal> expands to a 32-bit
    BCD-encoded representation of the Yasm version, with the major
    version in the most significant 8 bits, followed by the 8-bit
    minor version and 8-bit subminor version, and 0 in the least
    significant 8 bits.  For example, under Yasm 0.5.1,
    <literal>__YASM_MAJOR__</literal> would be defined to be 0,
    <literal>__YASM_MINOR__</literal> would be defined as 5,
    <literal>__YASM_SUBMINOR__</literal> would be defined as 1,
    <literal>__YASM_VER__</literal> would be defined as
    <literal>"0.5.1"</literal>, and
    <literal>__YASM_VERSION_ID__</literal> would be defined as
    <literal>000050100h</literal>.</para>

   <para>In addition, the single line macro
    <literal>__YASM_BUILD__</literal> expands to the Yasm
    <quote>build</quote> number, typically the Subversion changeset
    number.  It should be seen as less significant than the subminor
    version, and is generally only useful in discriminating between
    Yasm nightly snapshots or pre-release (e.g. release candidate)
    Yasm versions.</para>
  </section>

  <section id="nasm-stdmac-fileline">
   <title><literal>__FILE__</literal> and <literal>__LINE__</literal>:
    File Name and Line Number</title>

   <indexterm>
    <primary><literal>__FILE__</literal></primary>
   </indexterm>

   <indexterm>
    <primary><literal>__LINE__</literal></primary>
   </indexterm>

   <para>Like the C preprocessor, the NASM preprocessor allows the
    user to find out the file name and line number containing the
    current instruction. The macro <literal>__FILE__</literal> expands
    to a string constant giving the name of the current input file
    (which may change through the course of assembly if
    <literal>%include</literal> directives are used), and
    <literal>__LINE__</literal> expands to a numeric constant giving
    the current line number in the input file.</para>

   <para>These macros could be used, for example, to communicate
    debugging information to a macro, since invoking
    <literal>__LINE__</literal> inside a macro definition (either
    single-line or multi-line) will return the line number of the
    macro <emphasis>call</emphasis>, rather than
    <emphasis>definition</emphasis>. So to determine where in a piece
    of code a crash is occurring, for example, one could write a
    routine <literal>stillhere</literal>, which is passed a line
    number in <literal>EAX</literal> and outputs something like
    <quote>line 155: still here</quote>. You could then write a
    macro</para>

   <programlisting>%macro notdeadyet 0
        push    eax
        mov     eax, __LINE__
        call    stillhere
        pop     eax
%endmacro</programlisting>

   <para>and then pepper your code with calls to
    <literal>notdeadyet</literal> until you find the crash
    point.</para>
  </section>

  <section id="nasm-stdmac-output-format">
   <title><literal>__YASM_OBJFMT__</literal> and
    <literal>__OUTPUT_FORMAT__</literal>: Output Object Format
    Keyword</title>

   <indexterm>
    <primary><literal>__YASM_OBJFMT__</literal></primary>
   </indexterm>

   <indexterm>
    <primary><literal>__OUTPUT_FORMAT__</literal></primary>
   </indexterm>

   <indexterm>
    <primary><option>-f</option></primary>
   </indexterm>

   <para><literal>__YASM_OBJFMT__</literal>, and its NASM-compatible
    alias <literal>__OUTPUT_FORMAT__</literal>, expand to the object
    format <replaceable>keyword</replaceable> specified on the command
    line with <option>-f <replaceable>keyword</replaceable></option>
    (see <xref linkend="yasm-option-oformat" />).  For example, if
     <command>yasm</command> is invoked with <option>-f elf</option>,
    <literal>__YASM_OBJFMT__</literal> expands to
    <literal>elf</literal>.</para>

   <para>These expansions match the option given on the command line
    exactly, even when the object formats are equivalent.  For
    example, <option>-f elf</option> and <option>-f elf32</option> are
    equivalent specifiers for the 32-bit ELF format, and
    <option>-f elf -m amd64</option> and <option>-f elf64</option> are
    equivalent specifiers for the 64-bit ELF format, but
    <literal>__YASM_OBJFMT__</literal> would expand to
    <literal>elf</literal> and <literal>elf32</literal> for the first
    two cases, and <literal>elf</literal> and <literal>elf64</literal>
    for the second two cases.</para>
  </section>

  <section id="nasm-stdmac-struc">
   <title><literal>STRUC</literal> and <literal>ENDSTRUC</literal>:
    Declaring Structure Data Types</title>

   <indexterm>
    <primary><literal>STRUC</literal></primary>
   </indexterm>

   <indexterm>
    <primary><literal>ENDSTRUC</literal></primary>
   </indexterm>

   <indexterm>
    <primary>Declaring Structure</primary>
   </indexterm>

   <para>The NASM preprocessor is sufficiently powerful that data
    structures can be implemented as a set of macros. The macros
    <literal>STRUC</literal> and <literal>ENDSTRUC</literal> are used
    to define a structure data type.</para>

   <para><literal>STRUC</literal> takes one parameter, which is the
    name of the data type. This name is defined as a symbol with the
    value zero, and also has the suffix <literal>_size</literal>
    appended to it and is then defined as an <literal>EQU</literal>
    giving the size of the structure. Once <literal>STRUC</literal>
    has been issued, you are defining the structure, and should define
    fields using the <literal>RESB</literal> family of
    pseudo-instructions, and then invoke <literal>ENDSTRUC</literal>
    to finish the definition.</para>

   <para>For example, to define a structure called
    <literal>mytype</literal> containing a longword, a word, a byte
    and a string of bytes, you might code</para>

   <programlisting>        struc   mytype
mt_long:        resd 1
mt_word:        resw 1
mt_byte:        resb 1
mt_str:         resb 32
        endstruc</programlisting>

   <para>The above code defines six symbols:
    <literal>mt_long</literal> as 0 (the offset from the beginning of
    a <literal>mytype</literal> structure to the longword field),
    <literal>mt_word</literal> as 4, <literal>mt_byte</literal> as 6,
    <literal>mt_str</literal> as 7, <literal>mytype_size</literal> as
    39, and <literal>mytype</literal> itself as zero.</para>

   <para>The reason why the structure type name is defined at zero is
    a side effect of allowing structures to work with the local label
    mechanism: if your structure members tend to have the same names
    in more than one structure, you can define the above structure
    like this:</para>

   <programlisting>        struc   mytype
.long:  resd 1
.word:  resw 1
.byte:  resb 1
.str:   resb 32
        endstruc</programlisting>

   <para>This defines the offsets to the structure fields as
    <literal>mytype.long</literal>, <literal>mytype.word</literal>,
    <literal>mytype.byte</literal> and
    <literal>mytype.str</literal>.</para>

   <para>Since NASM syntax has no <emphasis>intrinsic</emphasis>
    structure support, does not support any form of period notation to
    refer to the elements of a structure once you have one (except the
    above local-label notation), so code such as <literal>mov
     ax,[mystruc.mt_word]</literal> is not valid.
    <literal>mt_word</literal> is a constant just like any other
    constant, so the correct syntax is <literal>mov
     ax,[mystruc+mt_word]</literal> or <literal>mov
     ax,[mystruc+mytype.word]</literal>.</para>
  </section>

  <section id="nasm-stdmac-istruc">
   <title><literal>ISTRUC</literal>, <literal>AT</literal> and
    <literal>IEND</literal>: Declaring Instances of Structures</title>

   <indexterm>
    <primary><literal>ISTRUC</literal></primary>
   </indexterm>

   <indexterm>
    <primary><literal>AT</literal></primary>
   </indexterm>

   <indexterm>
    <primary><literal>IEND</literal></primary>
   </indexterm>

   <indexterm>
    <primary>Instances of Structures</primary>
   </indexterm>

   <para>Having defined a structure type, the next thing you typically
    want to do is to declare instances of that structure in your data
    segment. The NASM preprocessor provides an easy way to do this in
    the <literal>ISTRUC</literal> mechanism. To declare a structure of
    type <literal>mytype</literal> in a program, you code something
    like this:</para>

   <programlisting>mystruc:        istruc  mytype
        at mt_long, dd 123456
        at mt_word, dw 1024
        at mt_byte, db 'x'
        at mt_str,  db 'hello, world', 13, 10, 0
                iend</programlisting>

   <para>The function of the <literal>AT</literal> macro is to make
    use of the <literal>TIMES</literal> prefix to advance the assembly
    position to the correct point for the specified structure field,
    and then to declare the specified data. Therefore the structure
    fields must be declared in the same order as they were specified
    in the structure definition.</para>

   <para>If the data to go in a structure field requires more than one
    source line to specify, the remaining source lines can easily come
    after the <literal>AT</literal> line. For example:</para>

   <programlisting>        at mt_str, db 123,134,145,156,167,178,189
        db 190,100,0</programlisting>

   <para>Depending on personal taste, you can also omit the code part
    of the <literal>AT</literal> line completely, and start the
    structure field on the next line:</para>

   <programlisting>        at mt_str
        db 'hello, world'
        db 13,10,0</programlisting>
  </section>

  <section id="nasm-stdmac-align">
   <title><literal>ALIGN</literal> and <literal>ALIGNB</literal>: Data
    Alignment</title>

   <indexterm>
    <primary><literal>ALIGN</literal></primary>
   </indexterm>

   <indexterm>
    <primary><literal>ALIGNB</literal></primary>
   </indexterm>

   <para>The <literal>ALIGN</literal> and <literal>ALIGNB</literal>
    macros provide a convenient way to align code or data on a word,
    longword, paragraph or other boundary.  The syntax of the
    <literal>ALIGN</literal> and <literal>ALIGNB</literal> macros
    is</para>

   <programlisting>        align 4                 ; align on 4-byte boundary
        align 16                ; align on 16-byte boundary
        align 16,nop            ; equivalent to previous line
        align 8,db 0            ; pad with 0s rather than NOPs
        align 4,resb 1          ; align to 4 in the BSS
        alignb 4                ; equivalent to previous line</programlisting>

   <para>Both macros require their first argument to be a power of
    two; they both compute the number of additional bytes required to
    bring the length of the current section up to a multiple of that
    power of two, and output either NOP fill or apply the
    <literal>TIMES</literal> prefix to their second argument to
    perform the alignment.</para>

   <para>If the second argument is not specified, the default for
    <literal>ALIGN</literal> is <literal>NOP</literal>, and the
    default for <literal>ALIGNB</literal> is <literal>RESB
     1</literal>.  <literal>ALIGN</literal> treats a
    <literal>NOP</literal> argument specially by generating maximal
    NOP fill instructions (not necessarily NOP opcodes) for the
    current <literal>BITS</literal> setting, whereas
    <literal>ALIGNB</literal> takes its second argument literally.
    Otherwise, the two macros are equivalent when a second argument is
    specified.  Normally, you can just use <literal>ALIGN</literal> in
    code and data sections and <literal>ALIGNB</literal> in BSS
    sections, and never need the second argument except for special
    purposes.</para>

   <para><literal>ALIGN</literal> and <literal>ALIGNB</literal>, being
    simple macros, perform no error checking: they cannot warn you if
    their first argument fails to be a power of two, or if their
    second argument generates more than one byte of code. In each of
    these cases they will silently do the wrong thing.</para>

   <para><literal>ALIGNB</literal> (or <literal>ALIGN</literal> with a
    second argument of <literal>RESB 1</literal>) can be used within
    structure definitions:</para>

   <programlisting>        struc   mytype2
mt_byte:        resb 1
                alignb 2
mt_word:        resw 1
                alignb 4
mt_long:        resd 1
mt_str:         resb 32
        endstruc</programlisting>

   <para>This will ensure that the structure members are sensibly
    aligned relative to the base of the structure.</para>

   <para>A final caveat: <literal>ALIGNB</literal> works relative to
    the beginning of the <emphasis>section</emphasis>, not the
    beginning of the address space in the final executable. Aligning
    to a 16-byte boundary when the section you're in is only
    guaranteed to be aligned to a 4-byte boundary, for example, is a
    waste of effort. Again, Yasm does not check that the section's
    alignment characteristics are sensible for the use of
    <literal>ALIGNB</literal>.  <literal>ALIGN</literal> is more
    intelligent and <emphasis>does</emphasis> adjust the section
    alignment to be the maximum specified alignment.</para>
  </section>
 </section>
</chapter>
