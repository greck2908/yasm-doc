<?xml version="1.0"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
		"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<!-- $Id$ -->
<chapter id="architecture">
 <title>Architecture</title>

 <para>Yasm is conceptually divided into a number of separable
  modules.</para>

 <para>Assuming that the programmatic interface of each module is
  well-defined, it is easy to customize the different parts of the
  assembler.  Contributors can write new parsers, new preprocessors,
  new optimizers, and new object formats.  Multiple types of each
  module may be simultaneously compiled in and are user-selectable at
  runtime via command-line or other configuration methods.</para>

 <para><xref linkend="architecture-pipeline"/> illustrates the 3-stage
  pipeline architecture of the assembler, and where each particular
  interface fits between the pipeline stages.  The data passed between
  each stage is structured as a linked list of bytecodes (an internal
  representation of a machine instruction or assembler
  pseudo-instruction, see <xref linkend="data-structures.bytecode"/>
  for more information).  Two additional stages are shown in <xref
   linkend="architecture-pipeline"/>, the preprocessor and the debug
  format, which while being major components of the overall
  architecture, execute in parallel with a main pipeline stage.</para>

 <para>However, yasm isn't a pipeline in the traditional computer
  architecture sense of the word, as none of the stages execute in
  parallel.</para>

 <figure id="architecture-pipeline">
  <title>Pipeline Architecture of Yasm</title>

  <mediaobject>
   <imageobject role="fo">
    <imagedata fileref="pipeline.svg" format="SVG" />
   </imageobject>
   <imageobject role="html">
    <imagedata fileref="pipeline.png" format="PNG" />
   </imageobject>
  </mediaobject>
 </figure>

 <para>In addition to the main pipeline shown in <xref
   linkend="architecture-pipeline"/>, a number of additional modules
  are necessary in order to have a fully functional assembler.  Some
  of these modules are called from multiple stages and thus must be
  able to function under many different conditions.  <xref
   linkend="architecture-modular"/> shows how the pipeline interfaces
  with these additional modules to create a complete assembler.</para>

 <figure id="architecture-modular">
  <title>Modular Architecture of Yasm</title>

  <mediaobject>
   <imageobject role="fo">
    <imagedata fileref="modular.svg" format="SVG" />
   </imageobject>
   <imageobject role="html">
    <imagedata fileref="modular.png" format="PNG" />
   </imageobject>
  </mediaobject>
 </figure>

 <para>A variety of support modules provide basic data structures and
  I/O functions.  Many of these modules are called or used in some
  fashion by nearly every module shown in <xref
   linkend="architecture-modular"/>.  <xref
   linkend="architecture-support"/> shows the relationships between
  these support modules.</para>

 <figure id="architecture-support">
  <title>Yasm Support Modules</title>

  <mediaobject>
   <imageobject role="fo">
    <imagedata fileref="support.svg" format="SVG" />
   </imageobject>
   <imageobject role="html">
    <imagedata fileref="support.png" format="PNG" />
   </imageobject>
  </mediaobject>
 </figure>

 <para><xref linkend="architecture-multi"/> shows an example of a
  built-out assembler with multiple preprocessors, parsers, object
  formats, etc, and how all the pieces fit together.
 </para>

 <figure id="architecture-multi">
  <title>Built-out Yasm (example)</title>

  <mediaobject>
   <imageobject role="fo">
    <imagedata fileref="multi.svg" format="SVG" />
   </imageobject>
   <imageobject role="html">
    <imagedata fileref="multi.png" format="PNG" />
   </imageobject>
  </mediaobject>
 </figure>
</chapter>
